import { $ } from 'bun';
import path from 'path';
import process from 'process';
import fs from 'fs/promises';

const Paths = {
  codegen: {
    root: './packages/typsi/.codegen',
    codex: {
      root: './packages/typsi/.codegen/codex',
      emoji: './packages/typsi/.codegen/codex/src/modules/emoji.txt',
      sym: './packages/typsi/.codegen/codex/src/modules/sym.txt',
    },
  },
  src: {
    customRules: './packages/typsi/src/custom-rules.txt',
    variant: './packages/typsi/src/variant.txt',
  },
  typsi: {
    root: './packages/typsi',
  },
  generated: {
    emoji: './packages/typsi/generated/emoji.yml',
    sym: './packages/typsi/generated/sym.yml',
    variant: './packages/typsi/generated/variant.yml',
    customRules: './packages/typsi/generated/custom-rules.yml',
  },
  packageYml: './packages/typsi/package.yml',
};

const args = process.argv.slice(2);
const flags = {
  force: args.some(simpleFlag({ short: 'f', long: 'force' })),
};

if (flags.force) {
  try {
    await fs.rm(Paths.codegen.root, { recursive: true });
  } catch {}
}
if (!(await fs.exists(Paths.codegen.root))) {
  await fs.mkdir(Paths.codegen.root, { recursive: true });
}

if (!(await fs.exists(Paths.codegen.codex.root))) {
  await fs.mkdir(Paths.codegen.codex.root, { recursive: true });
  $.cwd(path.join(process.cwd(), Paths.codegen.codex.root));

  await $`git init`;
  await $`git remote add origin https://github.com/typst/codex`;
  await $`git fetch origin main`;
  await $`git checkout origin/main -- src/modules/emoji.txt src/modules/sym.txt`;
}

const targetSeq: Array<{
  path: string;
  output: string;
  prefix: string;
  suffix: string;
  word: boolean;
}> = [
  {
    path: Paths.codegen.codex.emoji,
    output: Paths.generated.emoji,
    prefix: ':',
    suffix: ':',
    word: false,
  },
  {
    path: Paths.codegen.codex.sym,
    output: Paths.generated.sym,
    prefix: '\\',
    suffix: '\\',
    word: false,
  },
  {
    path: Paths.src.variant,
    output: Paths.generated.variant,
    prefix: '\\',
    suffix: '\\',
    word: false,
  },
  {
    path: Paths.src.customRules,
    output: Paths.generated.customRules,
    prefix: '',
    suffix: '\\',
    word: false,
  },
];

for (const target of targetSeq) {
  const src = await fs.readFile(target.path, {
    encoding: 'utf-8',
  });
  const parsed = parse(src);
  const file = generateEspansoFile(
    target.prefix,
    target.suffix,
    target.word,
    parsed,
  );
  await fs.mkdir(path.dirname(target.output), { recursive: true });
  await fs.writeFile(target.output, file, { encoding: 'utf-8' });
}
await fs.writeFile(
  Paths.packageYml,
  `# Generated by Typsi\n\nincludes:\n${targetSeq
    .map(
      (target) => `  - ${path.posix.relative(Paths.typsi.root, target.output)}`,
    )
    .join('\n')}\n`,
  {
    encoding: 'utf-8',
  },
);

function parse(content: string): Map<string, Replacement> {
  const result = new Map<string, Replacement>();

  let mostRecentDeprecation: string | null = null;
  let mostRecentStem: string | null = null;
  for (const line of content.split(/\r?\n/)) {
    if (line.trim().length === 0) {
      continue;
    }

    let match: RegExpMatchArray | null;
    if ((match = /^[ ]*\/\/[ ]+(.+)$/.exec(line))) {
      // comment
    } else if ((match = /^@(.*)$/.exec(line))) {
      mostRecentDeprecation = match[1]!;
    } else if ((match = /^[ ]*([^ .][^ ]*)[ ]*(.*)$/.exec(line))) {
      let [_, name, value] = match;
      name = refineString(name);
      value = refineString(value);
      if (value) {
        result.set(name, {
          match: name,
          replacement: value,
          deprecation: mostRecentDeprecation,
        });
      }
      mostRecentStem = name;
      mostRecentDeprecation = null;
    } else if ((match = /^[ ]*(\.[^ ]+)[ ]*(.*)$/.exec(line))) {
      let [_, name, value] = match;
      name = refineString(name);
      value = refineString(value);
      if (value) {
        if (!result.has(mostRecentStem!)) {
          result.set(mostRecentStem!, {
            match: mostRecentStem!,
            replacement: value,
            deprecation: mostRecentDeprecation,
          });
        }
        result.set(mostRecentStem! + name, {
          match: mostRecentStem! + name,
          replacement: value,
          deprecation: mostRecentDeprecation,
        });
      }
      mostRecentDeprecation = null;
    } else {
      console.log(JSON.stringify(line));
    }
  }

  return result;
}

interface Replacement {
  match: string;
  replacement: string;
  deprecation: string | null;
}

function generateEspansoFile(
  prefix: string,
  suffix: string,
  word: boolean,
  map: Map<string, Replacement>,
): string {
  const lines = Array.from(map).map(([_, replacement]) =>
    generateEspansoEntry(prefix, suffix, word, replacement)
      .split('\n')
      .map((line) => `  ${line}`)
      .join('\n'),
  );

  return `# Generated by Typsi\nmatches:\n${lines.join('\n')}`;
}

function generateEspansoEntry(
  prefix: string,
  suffix: string,
  word: boolean,
  replacement: Replacement,
): string {
  return `${
    replacement.deprecation ? `# ${replacement.deprecation}\n` : ''
  }- { trigger: ${JSON.stringify(
    `${prefix}${replacement.match}${suffix}`,
  )}, replace: ${JSON.stringify(replacement.replacement)}, word: ${word} }`;
}

function simpleFlag({
  short,
  long,
}: {
  short?: string;
  long?: string;
}): (arg: string) => boolean {
  return (arg) => {
    if (arg == `--${long}`) return true;
    if (arg.length < 2) return false;
    if (arg[0] !== '-' || arg[1] === '-') return false;
    return arg.slice(1).includes('f');
  };
}

function refineString(
  text: string | undefined,
  noQuote: boolean = false,
): string {
  if (typeof text !== 'string') return '';
  if (text.at(0) === '"' && !noQuote) {
    try {
      return refineString(JSON.parse(text), true);
    } catch {}
  }
  let group;
  if ((group = /^U\+([0-9a-fA-F]+)$/.exec(text))) {
    return String.fromCodePoint(Number('0x' + group[1]));
  }
  return text;
}
